# Config file for the ad text editor
# For details of the TOML file format see https://toml.io/en/v1.0.0

# Top level config options
[editor]
# Display a welcome message when opening the editor without any files
show_splash = true
# Whether or not tab characters should be automatically replaced with `tabstop` spaces
expand_tab = true
# The number of spaces to render tab characters with
tabstop = 4
# Whether or not leading whitespace should be copied to new lines on pressing Return
match_indent = true
# Number of seconds to persist status messages for
status_timeout = 3
# Number of milliseconds allowed between left mouse clicks for registering a double click
double_click_ms = 200
# Maximum number of lines used when rendering the minibuffer state
minibuffer_lines = 8
# Shell command to be used for listing files when running the `find file` and `find repo file` commands
find_command = "fd --hidden"


[filesystem]
# Whether or not the 9p filesystem interface should be enabled or not
enabled = true
# Whether or not the 9p filesystem interface should attempt to automount via fuse on startup
auto_mount = false


# Configuration for tree-sitter based syntax highlighting. See :help for details on the required
# directory structure.
[tree_sitter]
# The directory to search for compiled *.so files for parsing each language.
parser_dir = "~/.ad/tree-sitter/parsers"
# The directory to search for syntax highlighting queries.
syntax_query_dir = "~/.ad/tree-sitter/queries"


# Global color scheme settings
#
# It is also possible to specify an absolute path to a colorscheme TOML file containing this section of the config
# like so:
#   colorscheme = "~/.ad/colorschemes/default_dark.toml"
[colorscheme]
# The default background color for all UI elements
bg = "#272822"
# The default foreground color for all UI elements
fg = "#F8F8F3"
# The background color for the status bar
bar_bg = "#4E415C"
# The foreground color for the sign / number column
signcol_fg = "#544863"
# The background highlight color for the selected line in the mini-buffer
minibuffer_hl = "#3E3549"

# Syntax highlighting settings for tree-sitter query captures
# Each key in this table should match a corresponding capture in one of your syntax highlighting
# queries. For example, if you had the following in your $lang.scm file:
#
#  (line_comment) @comment
#  (block_comment) @comment
#
# then the `comment` key in this table will define the styling for nodes matching line and block
# comments.
#
# The supported styling properties are:
#   - fg: string RRGGBB hex color code
#   - bg: string RRGGBB hex color code
#   - bold: boolean
#   - italic: boolean
#   - underline: boolean
# [colorscheme.syntax]
# # Required styling for default text and selections
# default = { fg = "#F8F8F3", bg = "#272822" }
# dot = { fg = "#F8F8F3", bg = "#336677" }
# load = { fg = "#F8F8F3", bg = "#957FB8" }
# exec = { fg = "#F8F8F3", bg = "#DD3D6F" }
# # Styling for tree-sitter query captures
# boolean = { fg = "#DCA561", bold = true }
# character = { fg = "#E1D995", italic = true }
# comment = { fg = "#5F5D4F", italic = true }
# constant = { fg = "#FFA066" }
# function = { fg = "#8793B5" }
# "function.macro" = { fg = "#FFA066" }
# keyword = { fg = "#DD3D6F" }
# module = { fg = "#2D4F67" }
# number = { fg = "#D27E99" }
# operator = { fg = "#DCA561" }
# punctuation = { fg = "#9CABCA" }
# string = { fg = "#E1D995" }
# type = { fg = "#85D6EC" }
# variable = { fg = "#F8F8F3" }
# "markup.italic" = { fg = "#F8F8F3", bg = "#1B1720", italic = true }
# "markup.bold" = { fg = "#F8F8F3", bg = "#1B1720", bold = true }
# "markup.heading" = { fg = "#8793B5", bold = true }
# "markup.raw" = { fg = "#5F5D4F", italic = true }
# "markup.quote" = { fg = "#957FB8", italic = true }
# "markup.link.url" = { fg = "#9CABCA", underline = true }
# "markup.link.label" = { fg = "#2D4F67", bold = true }
# "markup.list.unchecked" = { fg = "#DCA561", bold = true }
# "markup.list.checked" = { fg = "#85D6EC", bold = true }
# "markup.list" = { fg = "#9CABCA", bg = "#1B1720", bold = true }
# label = { fg = "#E6C384" }

[colorscheme.syntax]
# Core
default = { fg = "#F8F8F2", bg = "#272822" }
dot     = { fg = "#F8F8F2", bg = "#408080" }
load    = { fg = "#F8F8F2", bg = "#AE81FF" }
exec    = { fg = "#F8F8F2", bg = "#F92672" }

# Tree-sitter captures
boolean      = { fg = "#AE81FF", bold = true }      # purple
character    = { fg = "#E6DB74", italic = true }    # yellow
comment      = { fg = "#75715E", italic = true }    # comment gray
constant     = { fg = "#FD971F" }                   # orange
function     = { fg = "#A6E22E" }                   # green
"function.macro" = { fg = "#FD971F" }               # use orange
keyword      = { fg = "#F92672" }                   # pink/red
module       = { fg = "#66D9EF" }                   # cyan
number       = { fg = "#AE81FF" }                   # purple
operator     = { fg = "#F92672" }                   # same as keyword
punctuation  = { fg = "#F8F8F2" }
string       = { fg = "#E6DB74" }                   # yellow
type         = { fg = "#66D9EF" }                   # cyan
variable     = { fg = "#F8F8F2" }

"markup.italic"         = { fg = "#F8F8F2", bg = "#1B1720", italic = true }
"markup.bold"           = { fg = "#F8F8F2", bg = "#1B1720", bold  = true }
"markup.heading"        = { fg = "#A6E22E", bold = true }
"markup.raw"            = { fg = "#75715E", italic = true }
"markup.quote"          = { fg = "#AE81FF", italic = true }
"markup.link.url"       = { fg = "#66D9EF", underline = true }
"markup.link.label"     = { fg = "#A6E22E", bold = true }
"markup.list.unchecked" = { fg = "#FD971F", bold = true }
"markup.list.checked"   = { fg = "#66D9EF", bold = true }
"markup.list"           = { fg = "#F8F8F2", bg = "#1B1720", bold = true }

label = { fg = "#E6DB74" }  # same yellow


# Key mappings to programs that must be available on $PATH or commands.
# ~/.ad/bin is auto-added to the path
[keys.normal]
"<space> F" = { run = "fmt" }
">" = { run = "indent" }
"<" = { run = "unindent" }
# Window & Column management
"<space> w /" = { run = "new-column" }
"<space> w -" = { run = "new-window" }
"<space> w h" = { run = "prev-column" }
"<space> w j" = { run = "next-window" }
"<space> w k" = { run = "prev-window" }
"<space> w l" = { run = "next-column" }
# Buffer
"<space> d b" = { run = "delete-buffer" }
"<space> b p" = { run = "prev-buffer" }
"<space> b n" = { run = "next-buffer" }
"<space> b r" = { run = "reload-buffer" }
# Toggle comment
"<space> ;" = { run = "toggle-comment" }
# Navigate
"C-f" = { send_keys = "<page-down>" }
"C-b" = { send_keys = "<page-up>" }


# Filetype configuration

[filetypes.awk]
extensions = ["awk"]
first_lines = ["#!/usr/bin/awk -f", "#!/usr/bin/env -S awk -f"]

[filetypes.bash]
extensions = ["sh", "bash"]
first_lines = ["#!/usr/bin/bash", "#!/usr/bin/sh", "#!/usr/bin/env bash", "#!/usr/bin/env sh"]
lsp.command = "bash-language-server"
lsp.args = ["start"]
lsp.roots = [".git"]

[filetypes.c]
extensions = ["c", "h"]

[filetypes.go]
extensions = ["go"]

[filetypes.dart]
extensions = ["dart"]
lsp.command = "dart"
lsp.args = ["language-server", "--protocol=lsp"]
lsp.roots = ["melos.yaml", "pubspec.yaml"]

[filetypes.graphql]
extensions = ["graphql"]

[filetypes.json]
extensions = ["json"]

[filetypes.just]
filenames = ["justfile"]

[filetypes.make]
filenames = ["Makefile"]

[filetypes.markdown]
extensions = ["md"]

# [filetypes.plumbingrules]
# filenames = ["plumbing.rules"]
# re_syntax = "~/.ad/syntax/plumbing-rules.toml"

[filetypes.proto]
extensions = ["proto"]

[filetypes.python]
extensions = ["py"]
lsp.command = "pylsp"
lsp.roots = ["dummy.py"]

[filetypes.r]
extensions = ["R"]
lsp.command = "R"
lsp.args = ["--slave", "-e", "languageserver::run()"]
lsp.roots = ["dummy.R"]

[filetypes.rust]
extensions = ["rs"]
lsp.command = "rust-analyzer"
lsp.roots = ["Cargo.toml"]

[filetypes.scheme]
extensions = ["scm", "cora"]

[filetypes.sql]
extensions = ["sql"]

[filetypes.swift]
extensions = ["swift"]

[filetypes.toml]
extensions = ["toml"]

# [filetypes.txtar]
# extensions = ["txtar"]
# re_syntax = "~/.ad/syntax/txtar.toml"

[filetypes.yaml]
extensions = ["yaml", "yml"]
